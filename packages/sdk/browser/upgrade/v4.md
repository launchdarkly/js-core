# Upgrading to `@launchdarkly/js-client-sdk@4`

## Overview
Starting from js client sdk version 4, we've moved our source to
this monorepo and the node module will be named `@launchdarkly/js-client-sdk`
moving forward.

As such, the first steps to updating is installing the "new" package and swapping
all references from `launchdarkly-js-client-sdk` to `@launchdarkly/js-client-sdk`.

Below, you can find the potentially breaking changes that you will need to address to
successfully upgrade.

## Key changes

### Client creation

**Key differences:**
- Initialization is now split into 2 parts `createClient` and `start`
- Removed the use of `initialize` method

**Before (v3.x):**
```javascript
import LDClient from 'launchdarkly-js-client-sdk';

const client = LDClient.initialize('client-side-id', context, options);
```

**After (v4.x):**
```javascript
import { createClient } from '@launchdarkly/js-client-sdk';

// Create client
const client = createClient('client-side-id', context, options);

// Then start the client
client.start();
```

**Why this change?**
This two-step process ensures that you can register all event listeners and
perform any necessary setup before the client begins connecting to LaunchDarkly.
This eliminates race conditions where events might be missed if listeners were
registered after the client had already started initializing.

### Client initialization flow

The new SDK uses `waitForInitialization()` which returns a result object instead of rejecting promises.
The old `waitUntilReady()` method has been removed.

**Key differences:**
- `waitForInitialization()` now always resolves (never rejects) and returns a result object with a `status` field
- The `timeout` is now specified as an option object: `{ timeout: 5 }` instead of a direct parameter
- `waitUntilReady()` has been removed - use `waitForInitialization()` instead
- The result object allows you to handle all cases (success, failure, timeout) without try/catch

**Before (v3.x):**
```javascript
// Option 1: Using waitUntilReady (never rejects)
await client.waitUntilReady();

// Option 2: Using waitForInitialization (rejects on failure)
try {
  await client.waitForInitialization(5);
} catch (err) {
  // Failure - but this could be an unhandled rejection if not caught
}

// Option 3: Using event listeners
client.on('ready', () => {
  // Client is ready (success or failure)
});
client.on('initialized', () => {
  // Client initialized successfully
});
client.on('failed', (err) => {
  // Client failed to initialize
});
```

**After (v4.x):**
```javascript
// Recommended: Using waitForInitialization (always resolves with status)
const result = await client.waitForInitialization({ timeout: 5 });

if (result.status === 'complete') {
  // Client initialized successfully
} else if (result.status === 'failed') {
  // Client failed to initialize
  console.error('Initialization failed:', result.error);
} else if (result.status === 'timeout') {
  // Initialization timed out
  console.error('Initialization timed out');
}

// Note: Events still work if you prefer that approach
client.on('ready', () => {
  // Client is ready (success or failure)
});
client.on('initialized', () => {
  // Client initialized successfully
});
client.on('failed', (err) => {
  // Client failed to initialize
});
```

### Identify

The `identify()` method now always returns a result object and never throws errors.
This provides more predictable error handling.

**Key differences:**
- `identify()` now takes an options object as the second parameter: `{ hash: '...' }` instead of a direct hash string
- The method always returns a promise that resolves to a result object (never rejects)
- You must check the `status` field to determine success or failure
- The `hash` parameter is now part of the options object
- Callback support has been removed - use async/await or `.then()` instead

**Before (v3.x):**
```javascript
// Option 1: Using callback
client.identify(newContext, hash, (err, flags) => {
  if (err) {
    // Handle error
  } else {
    // Use flags
  }
});

// Option 2: Using promise (could throw)
try {
  const flags = await client.identify(newContext, hash);
  // Use flags
} catch (err) {
  // Handle error - but this might be an unhandled rejection
}
```

**After (v4.x):**
```javascript
// Always returns a result object, never throws
const result = await client.identify(newContext, { hash });

if (result.status === 'completed') {
  // Identification completed successfully
} else if (result.status === 'error') {
  // Identification encountered an error
} else if (result.status === 'timeout') {
  // Identification timed out
} else if (result.status === 'shed') {
  // Identification was shed (discarded due to multiple rapid calls)
  // This can happen when sheddable option is enabled
}
```

### Flag change event

The `change` event now receives the context and an array of changed flag keys as parameters.
> NOTE: we will no longer return the flag value object along with this event

**Key differences:**
- The `change` event listener now receives `(context, changedFlagKeys)` where `changedFlagKeys` is an array of strings
- The event does not include flag values - you must call `variation()` to get the current value
- Similarly `change:<flag-key>` event listener will now only recieve `(context)`

**Before (v3.x):**
```javascript
// The exact signature may have varied, but typically:
client.on('change', (changedFlags) => {
  // changedFlags is a key value pair where the flag key is mapped
  // to a diff object.
});
```

**After (v4.x):**
```javascript
// General change event - fires when any flags change
client.on('change', (context, changedFlagKeys) => {
  // context: The LDContext for which flags changed
  // changedFlagKeys: Array of flag keys that changed

  // Still need to call variation() to get current values
  changedFlagKeys.forEach(flagKey => {
    const flagValue = client.variation(flagKey, defaultValue);
  });
});

// Specific flag change event - fires when a specific flag changes
client.on('change:my-flag', (context) => {
  // Only fires when 'my-flag' changes
  const flagValue = client.variation('my-flag', false);
});
```
